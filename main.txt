from fastapi import FastAPI 
from sqlalchemy.ext.asyncio import async_sessionmaker
from crud import CRUD
from db import engine 
from typing import List
from models import User , Vehicle , VehicleOwnership
from http import HTTPStatus
from fastapi import HTTPException

from fastapi import WebSocket , WebSocketDisconnect , Depends
from typing import Dict



from schemas import UserCreate
from schemas import UserLogin
from schemas import NotificationBase , VehicleCreate ,VehicleOwnershipCreate


import schemas,models

from models import Notification

app = FastAPI(
    #swagger UI
    title = "Noted API",
    description= "This is a simple note taking service",
    docs_url="/"
)

session = async_sessionmaker(
    bind = engine,
    expire_on_commit= False
)

db = CRUD()



class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str,WebSocket] = {}

    async def connect(self,license_number: str,websocket:WebSocket):
        await websocket.accept()
        self.active_connections[license_number] = websocket

    def disconnect(self, license_number:str):
        self.active_connections.pop(license_number,None)

    async def send_personal_message(self,message:str,licence_number:str):
        if licence_number in self.active_connections:
            websocket = self.active_connections[licence_number]
            await websocket.send_text(message)

manager = ConnectionManager()
    



@app.websocket("/ws/{licence_number}")
async def websocket_endpoint(websocket: WebSocket,licence_number:str):
    await manager.connect(licence_number,websocket)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(licence_number)



@app.post('/notify',status_code=HTTPStatus.CREATED)
async def trigger_notification(notification_data: NotificationBase):
    new_notification = Notification (
   
        
        notification_message = notification_data.notification_message,
        notification_senttimestamp = notification_data.notification_senttimestamp,
        notification_status = notification_data.notification_status,
        violation_id = notification_data.violation_id,
        user_licensenumber = notification_data.licence_number

        
    )
    
    notifcationattributes = await db.add_notify_violation(session,new_notification.violation_id,new_notification.user_licensenumber,new_notification.notification_message)

    return notifcationattributes



@app.post('/register/',status_code=HTTPStatus.CREATED)
async def create_user(user_data: UserCreate):
    new_user = User(
        user_licensenumber=user_data.user_licensenumber,
        user_fname=user_data.user_fname,
        user_lname=user_data.user_lname,
        user_phonenumber=user_data.user_phonenumber,
        user_email=user_data.user_email,
        user_password=user_data.user_password
    )
    user = await db.add_user(session,new_user)

    return user

@app.post("/login",status_code=HTTPStatus.CREATED)
async def login_user(user: UserLogin):
    db_user = await db.authenticate_user(session, user.user_licensenumber, user.user_password)

    if not db_user:
        raise HTTPException(status_code=401, detail="Invalid license number or password")

    return {
        "message": "Login successful",
        "user_fname": db_user.user_fname,
        "user_email": db_user.user_email,
        "user_license": db_user.user_licensenumber
    }



#Create Vehicle
@app.post("/vehicles/",status_code=HTTPStatus.CREATED)
async def create_vehicle(vechile: VehicleCreate):
    new_vehicle = Vehicle(
        vechicle_type = vechile.vechicle_type,
        licenceplate_number = vechile.licenceplate_number
    )
    vehicle = await db.register_vehicle(session,new_vehicle,vechile.licenceplate_number)

    return vehicle


@app.post("/vehiclesowner/",status_code=HTTPStatus.CREATED)
async def create_vehicle_owner(vechileowner: VehicleOwnershipCreate):
    new_vehicle_ownership = VehicleOwnership(
                current_ownership = vechileowner.current_ownership,
                vehicle_id = vechileowner.vechicle_id,
                user_licenseNumber = vechileowner.user_licenseNumber
    )
    vehicleownership = await db.register_vehicle_owner(session,new_vehicle_ownership,vechileowner.current_ownership,vechileowner.vechicle_id,vechileowner.user_licenseNumber)

    return vehicleownership











